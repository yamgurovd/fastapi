# Подключение к PostgreSQL через SQLAlchemy

### Перед началом, можно создать дополнительную базу данных в DBeaver под названием booking (будет использоваться конкретно в этом проекте)

P.S. Можно пользоваться и базой по умолчанию postgres, никакой разницы не будет. Просто со временем вы скорее всего
будете писать другие проекты и все равно придется создавать новую базу данных под каждый проект.

⚠️ Внимание! Если у вас не получается создать базу booking, можете работать в базе postgres, чтобы обучение не
останавливалось. Шаг с созданием новой базы данных некритичен.

!["Dbeaver"](/course_helpers/3%20База%20данных%20и%20паттерны/BD6.png)
!["Dbeaver"](/course_helpers/3%20База%20данных%20и%20паттерны/BD7.png)

### По итогу вы должны увидеть нечто похожее: доступны две базы: postgres и booking. В каждой можно посмотреть схемы, таблицы и пр.

!["Dbeaver"](/course_helpers/3%20База%20данных%20и%20паттерны/BD8.png)

## Виды баз данных

Бэкенд немыслим без хранилища данных, в качестве хранилища может выступать практически что угодно — список или словарик
внутри нашей Python программы, простой текстовый файл на компьютере, базы данных внутри оперативной памяти и базы данных
на жестком диске.

Хранение важных данных в программе Python или внутри оперативной памяти хоть и позволяет быстро к ним обращаться, имеет
один огромный минус — при выключении программы или выключении компьютера/сервера все данные навсегда стираются. Если мы
хотим надежно хранить наши данные и иметь возможность к ним обращаться даже после перезагрузки компьютера/сервера, то
необходимо использовать базы данных (БД) с хранением данных на жестком диске.

БД можно разделить на два типа: реляционные (в формате таблиц) и нереляционные (обычно в формате JSON — аналоге словаря
в Python, грубо говоря).

Давайте рассмотрим их отличия на простых примерах.

В реляционных БД обычно хранят данные одинаковой структуры, которая не меняется со временем. Например, мы можем хранить
таблицу пользователей, у каждого из которых есть лишь два поля: имя и фамилия.

### Пример таблицы в реляционной (SQL) БД:

!["Dbeaver"](/course_helpers/3%20База%20данных%20и%20паттерны/BD9.png)

### Пример записей в нереляционной (NoSQL) БД.

Самый распространенный пример — это интернет-магазин с товарами, у каждого из которых есть свое уникальное свойство.
Например, у часов есть характеристика защита от влаги и ширина ремешка, в то время как у печенек нету таких свойств,
зато есть другие — срок годности и форма печенек.

#### Пример записей в NoSQL БД

```sql
{
    "products": [
        {
            "product_id": 1,
            "name": "Печенье ручной работы",
            "product_type": "печенье",
            "price": 505,
            "details": {
                "expiry_date": 280,
                "form": "Фигурное" 
            }
        },
        {
            "product_id": 2,
            "name": "Часы Cacasio B1408",
            "product_type": "часы наручные",
            "price": 5990,
            "details": {
                "diameter": 44,
                "strap_width": 30
            }
        },
    ]
}
```

## Работа с базой данных из Python. Сырые SQL запросы vs ORM

Здесь и далее будет рассматриваться и описываться работа с реляционными базами данных, а именно с PostgreSQL. С
нереляционными БД также можно работать из Python, для этого есть специальные библиотеки, например, pymongo для работы с
MongoDB. Для работы с определенной базой данных необходима определенная библиотека, заточенная именно под эту базу
данных, например для работы с MySQL может понадобиться библиотека PyMySQL, а для работы с PostgreSQL можно выбрать среди
psycopg2, asyncpg, aiopg. Для синхронной работы с Postgres используется psycopg2, для асинхронной — обычно asyncpg, реже
aiopg.

Важно понимать, что все эти библиотеки делают одно и тоже — отправляют сформированный вами запрос в базу данных. Разница
в том, какой интерфейс (какие классы и функции) для создания запросов они предоставляют разработчику и предоставляют ли
они возможность исполнять запросы асинхронно.

Несмотря на то, что многие знают и любят писать сырые SQL запросы через Python, порой гораздо удобнее писать их на "
питонячьем" языке, то есть используя так называемый ORM. ORM — object-relational mapping или объектно-реляционное
отображение — это способ взаимодействия приложения с базой данных посредством синтаксиса языка, на котором написано
приложение. Объекты — это представление таблиц (реляций) на языке программирования (в нашем случае Python). Например,
для простой выборки данных из таблицы users вместо запроса

```python
query = "SELECT * FROM users"
```

на языке SQL мы можем использовать синтаксис языка Python для написания точно такого же запроса через

```python
query = select(Users)
```

Понятное дело, что под капотом функции select и класса Users находится указание на язык SQL. Для Python есть одна
невероятно популярная библиотека, которая дает возможность писать SQL запросы, используя конструкции языка Python — она
называется SQLAlchemy. SQLAlchemy сама не отправляет запросы в БД, для этих целей она использует уже готовые библиотеки,
называемые драйверами, например, psycopg2 или asyncpg. SQLAlchemy дает возможность формировать как сырые SQL запросы,
так и писать через ORM.

#### Плюсы SQLAlchemy:

- При использовании Алхимии можно работать с таблицами как с объектами на "питонячем" языке
- Алхимия защищает нас от SQL-инъекций
- Алхимия позволяет абстрагироваться от конкретной СУБД при написании запросов. Это позволяет сменить используемую базу
  данных, например, с MySQL на Postgres без больших трудностей

Если вы пришли из Django, то вы, конечно знакомы с ORM, но переход на ORM Алхимии может протекать не так быстро, как вы
ожидаете, ввиду больших отличий в названиях функций/методов и способах их применения.

Дорогие ученики. При попытке запустить приложение так же, как в видео, мы можете получить ошибку, связанную с событийным
циклом (event loop).

Если запустить код через

```shell
python src/main.py
```

как я, то ошибки не происходит, потому что не успевает создаться событийный цикл (он создается для работы uvicorn'а).

Если мы запускаем код через

```shell
uvicorn src.main:app
```

то событийный цикл успевает создаться еще до того, как интерпретатор дойдет до кода с нашим asyncio.run(...)


То есть если поменять в main.py код на 

```python
if __name__ == "__main__":
    uvicorn.run("main:app", reload=True)
```

и запускать приложение через python src/main.py, все должно работать.
